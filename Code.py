# -*- coding: utf-8 -*-
"""i222427_A_A2_q2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VR9VLbP9RLz0j_q28EqR80H2yBUBv-hd

**Assignment 2 Question 2**
"""

import random
import pandas as pd

# Define shelf constraints
shelves = {
    "S1": {"name": "Checkout Display", "capacity": 8, "products": []},
    "S2": {"name": "Lower Shelf", "capacity": 25, "products": []},
    "S4": {"name": "Eye-Level Shelf", "capacity": 15, "products": []},
    "S5": {"name": "General Aisle Shelf", "capacity": 20, "products": []},
    "R1": {"name": "Refrigerator Zone", "capacity": 20, "products": []},
    "H1": {"name": "Hazardous Zone", "capacity": 10, "products": []},
}

# Read products from file
def load_products(filename):
    products = []
    with open(filename, "r") as file:
        for line in file:
            name, weight, category, allowed_shelves = line.strip().split(",")[:4]
            weight = int(weight)
            shelves_list = allowed_shelves.split("/")
            products.append({"name": name, "weight": weight, "category": category, "allowed_shelves": shelves_list})
    return products

# Fitness function (lower is better)
def fitness(shelf_allocation):
    score = 0

    # Check weight capacity
    for shelf, data in shelf_allocation.items():
        total_weight = sum(item["weight"] for item in data["products"])
        if total_weight > data["capacity"]:
            score += (total_weight - data["capacity"]) * 20  # Higher penalty for exceeding weight

    # Check logical product placement
    for shelf, data in shelf_allocation.items():
        categories = set(item["category"] for item in data["products"])
        if shelf == "R1" and not all(item["category"] in ["Dairy", "Frozen"] for item in data["products"]):
            score += 30  # Non-refrigerated items in fridge
        if shelf == "H1" and not all(item["category"] == "Cleaning" for item in data["products"]):
            score += 30  # Non-hazardous items in hazardous zone
        if len(categories) > 3:  # Try to group similar categories
            score += (len(categories) - 3) * 10

    return score

# Improved initial allocation strategy
def allocate_products(products):
    allocation = {s: {"name": shelves[s]["name"], "capacity": shelves[s]["capacity"], "products": []} for s in shelves}
    for product in sorted(products, key=lambda x: -x["weight"]):  # Place heavier products first
        possible_shelves = sorted(product["allowed_shelves"], key=lambda s: allocation[s]["capacity"])
        for shelf in possible_shelves:
            current_weight = sum(item["weight"] for item in allocation[shelf]["products"])
            if current_weight + product["weight"] <= allocation[shelf]["capacity"]:
                allocation[shelf]["products"].append(product)
                break
    return allocation

# Generate an initial random population
def generate_population(products, size=10):
    return [allocate_products(products) for _ in range(size)]

def crossover(parent1, parent2):
    child = {s: {"name": shelves[s]["name"], "capacity": shelves[s]["capacity"], "products": []} for s in shelves}

    for shelf in shelves:
        # Merge without duplicates using dictionary keys
        merged_products = parent1[shelf]["products"] + parent2[shelf]["products"]
        child[shelf]["products"] = list({p["name"]: p for p in merged_products}.values())

        # Ensure shelf does not exceed capacity
        while sum(p["weight"] for p in child[shelf]["products"]) > shelves[shelf]["capacity"]:
            child[shelf]["products"].pop()  # Remove last item to fit within the limit

    return child


# Mutation function (swaps items within allowed shelves)
def mutate(allocation, products):
    shelf_keys = list(shelves.keys())
    for _ in range(2):  # Mutate two products
        product = random.choice(products)
        current_shelf = next((s for s in shelf_keys if product in allocation[s]["products"]), None)
        if current_shelf:
            allocation[current_shelf]["products"].remove(product)
        new_shelf = random.choice(product["allowed_shelves"])
        allocation[new_shelf]["products"].append(product)
    return allocation

# Genetic Algorithm
def genetic_algorithm(products, generations=100, population_size=20):
    population = generate_population(products, population_size)

    for _ in range(generations):
        population = sorted(population, key=lambda x: fitness(x))  # Sort by best fitness
        new_population = population[:5]  # Keep top 5
        while len(new_population) < population_size:
            parent1, parent2 = random.sample(population[:10], 2)
            child = crossover(parent1, parent2)
            if random.random() < 0.3:  # 30% chance of mutation
                child = mutate(child, products)
            new_population.append(child)
        population = new_population

    return sorted(population, key=lambda x: fitness(x))[0]  # Return best solution

# Run tests on all product files
for filename in ["/products_10.txt", "/products_25.txt", "/products_30.txt", "/products_50.txt"]:
    print(f"\nRunning test for {filename}...\n")
    products = load_products(filename)
    best_solution = genetic_algorithm(products)

    print("Optimized Shelf Allocation:")
    for shelf, data in best_solution.items():
        print(f"{shelf} ({data['name']}): {[p['name'] for p in data['products']]}")

    print("\nFitness Score:", fitness(best_solution))